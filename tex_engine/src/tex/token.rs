/*!
    [`Token`]s are the basic "characters" a TeX Engine operates on.

    There are two kinds of [`Token`]s:
    - A *Character Token* is a pair of a character (of type `Char:`[`CharType`]) and its [`CategoryCode`],
        represented by [`BaseToken::Char`].
    - A *Control Sequence Token* is a [`TeXStr`] (a string of characters) and is represented by [`BaseToken::CS`],
        usually generated by `\` followed by a string of letters (or a single non-letter character).
 */

use std::fmt::Debug;
use crate::engine::EngineType;
use crate::engine::memory::{Interner, Memory};
use crate::tex::catcodes::CategoryCode;
use crate::tex::commands::CommandSource;
use crate::utils::Ptr;
use crate::utils::strings::{CharType, TeXStr};

/// A [`BaseToken`] bundles the actually TeX-relevant data of a [`Token`], which is cloned often
/// and required by all [`Token`] implementations
#[derive(Clone,Copy,Debug)]
pub enum BaseToken<C:CharType> {
    /// A control sequence token with the provided name
    CS(TeXStr<C>),
    /// An active character token with the provided character
    Char(C, CategoryCode)
}
impl<C:CharType> BaseToken<C> {
    pub fn to_str(& self,interner:&Interner<C>,escapechar:Option<C>) -> String {
        match self {
            BaseToken::Char(c, _) => c.as_char().to_string(),
            BaseToken::CS(n) => match escapechar {
                Some(c) => (c.as_char().to_string() + n.to_str(interner)).to_string(),
                None => n.to_str(interner).to_string()
            }
        }
    }
}
impl<C:CharType> PartialEq for BaseToken<C> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (BaseToken::Char(_, CategoryCode::Space), BaseToken::Char(_,CategoryCode::Space)) => true,
            (BaseToken::Char(c1, cc1), BaseToken::Char(c2, cc2)) => c1 == c2 && cc1 == cc2,
            (BaseToken::CS(n1), BaseToken::CS(n2)) => n1 == n2,
            _ => false
        }
    }
}
/*
impl<C:CharType> Display for BaseToken<C> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            BaseToken::Char(c, _) => write!(f, "{}", c.char_str()),
            BaseToken::CS(n) => write!(f, "\\{}", )
        }
    }
}
impl<C:CharType> Debug for BaseToken<C> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        use ansi_term::Colour::*;
        use CategoryCode::*;
        match self {
            BaseToken::Char(c, cc) => write!(f, "'{}'", match cc {
                BeginGroup => Green.bold().paint(c.char_str()),
                EndGroup => Green.paint(c.char_str()),
                Active => Red.paint(c.char_str()),
                Space => ansi_term::Style::new().paint(c.char_str()),
                Parameter => Yellow.paint(c.char_str()),
                AlignmentTab => Blue.paint(c.char_str()),
                MathShift => Purple.paint(c.char_str()),
                Subscript => Cyan.paint(c.char_str()),
                Superscript => Cyan.bold().paint(c.char_str()),
                Letter => White.bold().paint(c.char_str()),
                Comment => White.paint(c.char_str()),
                _ => ansi_term::Style::new().paint(c.char_str())
            }),
            BaseToken::CS(n) => write!(f, "{}{}", Red.paint("\\"), Red.paint(n.to_string()))
        }
    }
}

 */

#[derive(Clone,Copy, Debug)]
pub struct Token<ET:EngineType> {
    pub base:BaseToken<ET::Char>,
    pub sourceref:Option<ET::TokenReference>
}


impl<ET:EngineType> Token<ET> {
    pub fn to_str(&self,interner:&Interner<ET::Char>,escapechar:Option<ET::Char>) -> String {
        self.base.to_str(interner,escapechar)
    }
}
impl<ET:EngineType> PartialEq for Token<ET> {
    fn eq(&self, other: &Self) -> bool {
        self.base == other.base
    }
}
impl<ET:EngineType> Token<ET> {
    /// The [`CategoryCode`] of the [`Token`]
    pub fn catcode(&self) -> CategoryCode {
        match &self.base {
            BaseToken::Char(_, cat) => *cat,
            BaseToken::CS(_) => CategoryCode::Escape
        }
    }
    pub fn new(base:BaseToken<ET::Char>, sourceref:Option<FileReference>) -> Self {
        Self {
            sourceref:sourceref.map(|fr| ET::TokenReference::from_file(&base,fr)),
            base
        }
    }
    pub fn with_ref(self, cmd:&ET::TokenReference) -> Self {
        Self {
            sourceref: Some(cmd.with_ref(&self.base)),
            base: self.base
        }
    }
}
/*
pub trait Token:PartialEq+Clone+Display+Debug+'static{
    type Char:CharType;
    /// The actual TeX-relevant data of the [`Token`]
    fn base(&self) -> &BaseToken<Self::Char>;

    /// Construct a new [`Token`] from a [`BaseToken`]
    fn new(base:BaseToken<Self::Char>,sourceref:Option<(Ptr<String>,(usize,usize),(usize,usize))>) -> Self;
    /// Clone this [`Token`] with a new [`SourceReference`] of type [`SourceReference::Expansion`]
    /// (if the [`Token`] is a [`TokenWithSourceref`]).
    fn with_ref<ET:EngineType<Token=Self>>(&self, cmd:&CommandSource<ET>) -> Self;
    fn sourceref_trace(&self) -> Option<String>;
    fn take_base(self) -> BaseToken<Self::Char>;
}
 */


#[derive(Clone,Copy,Debug,PartialEq)]
pub struct FileReference {
    pub filename:string_interner::DefaultSymbol,
    pub start:(usize,usize),
    pub end:(usize,usize)
}

pub trait TokenReference<ET:EngineType<TokenReference = Self>>:Clone + Debug {
    fn from_expansion(cmd:&CommandSource<ET>) -> Self;
    fn from_file(base:&BaseToken<ET::Char>,fr:FileReference) -> Self;
    fn with_ref(&self,base:&BaseToken<ET::Char>) -> Self { self.clone() }
    fn trace(&self,interner:&Interner<ET::Char>) -> Option<String> { None }
}
impl<ET:EngineType<TokenReference = Self>> TokenReference<ET> for () {
    fn from_expansion(_cmd: &CommandSource<ET>) -> Self { () }
    fn from_file(_base: &BaseToken<ET::Char>, _fr: FileReference) -> Self { () }
}

#[derive(Clone,Debug,PartialEq,Copy)]
pub enum FileReferenceOnly {
    File(FileReference), None
}
impl<ET:EngineType<TokenReference = Self>> TokenReference<ET> for FileReferenceOnly {
    fn from_expansion(cmd: &CommandSource<ET>) -> Self {
        match &cmd.cause.sourceref {
            None|Some(FileReferenceOnly::None) => FileReferenceOnly::None,
            Some(FileReferenceOnly::File(fr)) => FileReferenceOnly::File(fr.clone())
        }
    }
    fn from_file(_: &BaseToken<ET::Char>, fr: FileReference) -> Self { FileReferenceOnly::File(fr) }
}

#[derive(Clone,Debug,PartialEq)]
pub enum FileTokenReferenceI<ET:EngineType<TokenReference = FileTokenReference<ET>>> {
    File(FileReference),
    Expansion{cmd:Option<ET::CommandReference>, token: Token<ET>}
}
impl<ET:EngineType<TokenReference = FileTokenReference<ET>>> FileTokenReferenceI<ET> {
    pub fn trace(&self,interner:&Interner<ET::Char>) -> Option<String> {
        use FileTokenReferenceI::*;
        match self {
            File (FileReference{filename, start,end}) => Some(format!("File {} at {}:{} - {}:{}",interner.resolve(*filename), start.0,start.1,end.0,end.1)),
            Expansion {token, ..} => {
                let mut trace = format!("Expanded from {}",token.to_str(interner,Some(ET::Char::backslash())));
                match token.sourceref.as_ref().map(|r|r.trace(interner)).flatten() {
                    Some(s) => {
                        trace.push_str("\n - ");
                        trace.push_str(&s)
                    },
                    None => ()
                }
                Some(trace)
            }
        }
    }
}

pub type FileTokenReference<ET> = Ptr<FileTokenReferenceI<ET>>;
impl<ET:EngineType<TokenReference = Self>> TokenReference<ET> for FileTokenReference<ET> {
    fn from_expansion(cmd: &CommandSource<ET>) -> Self {
        Ptr::new(FileTokenReferenceI::Expansion{
            cmd: cmd.reference.clone(),
            token: cmd.cause.clone()
        })
    }
    fn from_file(_: &BaseToken<ET::Char>, fr: FileReference) -> Self { Ptr::new(FileTokenReferenceI::File(fr)) }
    fn trace(&self, interner: &Interner<ET::Char>) -> Option<String> {
        FileTokenReferenceI::trace(self,interner)
    }
}


/// A list of [`Token`]s
pub struct TokenList<'a,ET:EngineType>(pub &'a [Token<ET>]);
impl <'a,ET:EngineType> TokenList<'a,ET> {
    pub fn to_str(&self,interner:&Interner<ET::Char>) -> String {
        let mut s = String::new();
        for t in self.0 {
            s.push_str(&t.to_str(interner,Some(ET::Char::backslash())));
        }
        s
    }
}
impl<'a,ET:EngineType> Into<TokenList<'a,ET>> for &'a Vec<Token<ET>> {
    fn into(self) -> TokenList<'a,ET> { TokenList(self.as_slice()) }
}

/*
/// A [`Token`] bundling a [`BaseToken`] with a [`SourceReference`].
#[derive(Clone)]
pub struct TokenWithSourceref<ET:EngineType<Token=Self>>{
    /// The actual TeX-relevant data of the [`Token`]
    pub base: BaseToken<ET::Char>,
    /// The [`SourceReference`] of the [`Token`]
    pub sourceref: Option<SourceReference<ET>>
}
impl<ET:EngineType<Token=Self>> Token for TokenWithSourceref<ET> {
    type Char = ET::Char;
    fn base(&self) -> &BaseToken<Self::Char> { &self.base }
    fn take_base(self) -> BaseToken<Self::Char> {
        self.base
    }
    fn new(base:BaseToken<Self::Char>,sourceref:Option<(Ptr<String>,(usize,usize),(usize,usize))>) -> Self {
        Self { base, sourceref: sourceref.map(|tr| SourceReference::File {
            file: tr.0,
            start: tr.1,
            end: tr.2
        }) }
    }
    fn with_ref<IET:EngineType>(&self, cmd:&CommandSource<IET>) -> Self {
        use std::any::Any;
        let sourceref = match (cmd as &dyn Any).downcast_ref::<CommandSource<ET>>() {
            Some(cmd) => Some(SourceReference::Expansion {token:Box::new(cmd.cause.clone()),cmd:cmd.reference.clone()}),
            _ => None
        };
        Self { base: self.base.clone(), sourceref }
    }
    fn sourceref_trace(&self) -> Option<String> {
        match &self.sourceref {
            Some(SourceReference::File {file, start,end}) => Some(format!("File {} at {}:{} - {}:{}", file, start.0,start.1,end.0,end.1)),
            Some(SourceReference::Expansion {token, ..}) => {
                let mut trace = format!("Expanded from {}",token);
                match token.sourceref_trace() {
                    Some(s) => {
                        trace.push_str("\n - ");
                        trace.push_str(&s)
                    },
                    None => ()
                }
                Some(trace)
            },
            None => None
        }
    }
}
impl<ET:EngineType<Token=Self>> PartialEq for TokenWithSourceref<ET> {
    fn eq(&self, other: &Self) -> bool { PartialEq::eq(&self.base,&other.base) }
}
impl<ET:EngineType<Token=Self>>Display for TokenWithSourceref<ET> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result { Display::fmt(&self.base,f) }
}
impl<ET:EngineType<Token=Self>> Debug for TokenWithSourceref<ET> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self.sourceref {
            Some(ref s) => write!(f, "{:?} at {:?}", self.base, s),
            None => write!(f, "{:?}", self.base)
        }
    }
}


/// A [`SourceReference`] allows tracking the origin of a [`Token`]. It is either a file reference
/// or a reference to an expansion: The result of expanding a control sequence token.
#[derive(Clone)]
pub enum SourceReference<ET:EngineType> {
    /// A reference to a file, with the file name and the start and end position of the
    /// [`Token`] in the file.
    File{file: Ptr<String>,start:(usize,usize),end:(usize,usize)},
    /// A reference to an expansion, with the [`Token`] that was expanded via [`BaseCommand`].
    Expansion{token: Box<Token<ET>>,cmd:Option<ET::CommandReference>}
}
impl<ET:EngineType> Debug for SourceReference<ET> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            SourceReference::File{file,start,end} => write!(f, "File {}; {:?} - {:?}", file, start, end),
            SourceReference::Expansion{token,cmd} => write!(f, "Expansion of {} via {:?}", token, cmd)
        }
    }
}

 */